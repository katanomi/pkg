From b7aefbaf9dbab97e6b3b7e13eaa311404756055a Mon Sep 17 00:00:00 2001
From: jtcheng <jtcheng@alauda.io>
Date: Mon, 28 Oct 2024 19:15:39 +0800
Subject: [PATCH] remove unused param logic based on tekton definition

Signed-off-by: jtcheng <jtcheng@alauda.io>
---
 apis/meta/v1alpha1/param_types.go      | 408 +-----------------
 apis/meta/v1alpha1/param_types_test.go | 564 +++++--------------------
 2 files changed, 131 insertions(+), 841 deletions(-)

diff --git a/apis/meta/v1alpha1/param_types.go b/apis/meta/v1alpha1/param_types.go
index c597354..f4c712c 100644
--- a/apis/meta/v1alpha1/param_types.go
+++ b/apis/meta/v1alpha1/param_types.go
@@ -1,5 +1,5 @@
 /*
-Copyright 2022 The Tekton Authors
+Copyright 2024 The Katanomi Authors.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -14,28 +14,21 @@ See the License for the specific language governing permissions and
 limitations under the License.
 */

-package v1
+// Code generated by hack/patch-tekton-params.sh DO NOT EDIT.
+
+package v1alpha1

 import (
 	"context"
 	"encoding/json"
 	"fmt"
-	"strings"
-
-	"github.com/tektoncd/pipeline/pkg/apis/config"
-	"github.com/tektoncd/pipeline/pkg/substitution"
-	corev1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/util/sets"
 	"k8s.io/utils/strings/slices"
 	"knative.dev/pkg/apis"
 )

-// ParamsPrefix is the prefix used in $(...) expressions referring to parameters
-const ParamsPrefix = "params"
-
 // ParamSpec defines arbitrary parameters needed beyond typed inputs (such as
-// resources). Parameter values are provided by users as inputs on a TaskRun
-// or PipelineRun.
+// resources).
 type ParamSpec struct {
 	// Name declares the name by which a parameter is referenced.
 	Name string `json:"name"`
@@ -50,18 +43,17 @@ type ParamSpec struct {
 	// Properties is the JSON Schema properties to support key-value pairs parameter.
 	// +optional
 	Properties map[string]PropertySpec `json:"properties,omitempty"`
-	// Default is the value a parameter takes if no input value is supplied. If
-	// default is set, a Task may be executed without a supplied value for the
-	// parameter.
+	// Default is the value a parameter takes if no input value is supplied.
 	// +optional
 	Default *ParamValue `json:"default,omitempty"`
-	// Enum declares a set of allowed param input values for tasks/pipelines that can be validated.
+	// Enum declares a set of allowed param input values.
 	// If Enum is not set, no input validation is performed for the param.
 	// +optional
 	Enum []string `json:"enum,omitempty"`
 }

 // ParamSpecs is a list of ParamSpec
+// +listType=atomic
 type ParamSpecs []ParamSpec

 // PropertySpec defines the struct for object keys
@@ -111,7 +103,7 @@ func (pp *ParamSpec) setDefaultsForProperties() {

 // GetNames returns all the names of the declared parameters
 func (ps ParamSpecs) GetNames() []string {
-	var names []string
+	var names = []string{}
 	for _, p := range ps {
 		names = append(names, p.Name)
 	}
@@ -147,15 +139,12 @@ func (ps ParamSpecs) ValidateNoDuplicateNames() *apis.FieldError {
 }

 // validateParamEnum validates feature flag, duplication and allowed types for Param Enum
-func (ps ParamSpecs) validateParamEnums(ctx context.Context) *apis.FieldError {
+func (ps ParamSpecs) validateParamEnums(_ context.Context) *apis.FieldError {
 	var errs *apis.FieldError
 	for _, p := range ps {
 		if len(p.Enum) == 0 {
 			continue
 		}
-		if !config.FromContextOrDefaults(ctx).FeatureFlags.EnableParamEnum {
-			errs = errs.Also(errs, apis.ErrGeneric(fmt.Sprintf("feature flag `%s` should be set to true to use Enum", config.EnableParamEnum), "").ViaKey(p.Name))
-		}
 		if p.Type != ParamTypeString {
 			errs = errs.Also(apis.ErrGeneric("enum can only be set with string type param", "").ViaKey(p.Name))
 		}
@@ -172,9 +161,9 @@ func (ps ParamSpecs) validateParamEnums(ctx context.Context) *apis.FieldError {
 }

 // findDups returns the duplicate element in the given slice
-func findDups(vals []string) sets.String {
-	seen := sets.String{}
-	dups := sets.String{}
+func findDups(vals []string) sets.Set[string] {
+	seen := sets.Set[string]{}
+	dups := sets.Set[string]{}
 	for _, val := range vals {
 		if seen.Has(val) {
 			dups.Insert(val)
@@ -190,32 +179,9 @@ type Param struct {
 	Value ParamValue `json:"value"`
 }

-// GetVarSubstitutionExpressions extracts all the value between "$(" and ")"" for a Parameter
-func (p Param) GetVarSubstitutionExpressions() ([]string, bool) {
-	var allExpressions []string
-	switch p.Value.Type {
-	case ParamTypeArray:
-		// array type
-		for _, value := range p.Value.ArrayVal {
-			allExpressions = append(allExpressions, validateString(value)...)
-		}
-	case ParamTypeString:
-		// string type
-		allExpressions = append(allExpressions, validateString(p.Value.StringVal)...)
-	case ParamTypeObject:
-		// object type
-		for _, value := range p.Value.ObjectVal {
-			allExpressions = append(allExpressions, validateString(value)...)
-		}
-	default:
-		return nil, false
-	}
-	return allExpressions, len(allExpressions) != 0
-}
-
 // ExtractNames returns a set of unique names
-func (ps Params) ExtractNames() sets.String {
-	names := sets.String{}
+func (ps Params) ExtractNames() sets.Set[string] {
+	names := sets.Set[string]{}
 	for _, p := range ps {
 		names.Insert(p.Name)
 	}
@@ -244,224 +210,23 @@ func (ps Params) extractParamMapArrVals() map[string][]string {
 	return paramsMap
 }

-// ParseTaskandResultName parses "task name", "result name" from a Matrix Context Variable
-// Valid Example 1:
-// - Input: tasks.myTask.matrix.length
-// - Output: "myTask", ""
-// Valid Example 2:
-// - Input: tasks.myTask.matrix.ResultName.length
-// - Output: "myTask", "ResultName"
-func (p Param) ParseTaskandResultName() (string, string) {
-	if expressions, ok := p.GetVarSubstitutionExpressions(); ok {
-		for _, expression := range expressions {
-			subExpressions := strings.Split(expression, ".")
-			pipelineTaskName := subExpressions[1]
-			if len(subExpressions) == 4 {
-				return pipelineTaskName, ""
-			} else if len(subExpressions) == 5 {
-				resultName := subExpressions[3]
-				return pipelineTaskName, resultName
-			}
-		}
-	}
-	return "", ""
-}
-
 // Params is a list of Param
+// +listType=atomic
 type Params []Param

-// ExtractParamArrayLengths extract and return the lengths of all array params
-// Example of returned value: {"a-array-params": 2,"b-array-params": 2 }
-func (ps Params) ExtractParamArrayLengths() map[string]int {
-	// Collect all array params
-	arrayParamsLengths := make(map[string]int)
-
-	// Collect array params lengths from params
-	for _, p := range ps {
-		if p.Value.Type == ParamTypeArray {
-			arrayParamsLengths[p.Name] = len(p.Value.ArrayVal)
-		}
-	}
-	return arrayParamsLengths
-}
-
 // validateDuplicateParameters checks if a parameter with the same name is defined more than once
 func (ps Params) validateDuplicateParameters() (errs *apis.FieldError) {
-	taskParamNames := sets.NewString()
+	paramNames := sets.NewString()
 	for i, param := range ps {
-		if taskParamNames.Has(param.Name) {
+		if paramNames.Has(param.Name) {
 			errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("parameter names must be unique,"+
 				" the parameter \"%s\" is also defined at", param.Name), fmt.Sprintf("[%d].name", i)))
 		}
-		taskParamNames.Insert(param.Name)
+		paramNames.Insert(param.Name)
 	}
 	return errs
 }

-// ReplaceVariables applies string, array and object replacements to variables in Params
-func (ps Params) ReplaceVariables(stringReplacements map[string]string, arrayReplacements map[string][]string, objectReplacements map[string]map[string]string) Params {
-	params := ps.DeepCopy()
-	for i := range params {
-		params[i].Value.ApplyReplacements(stringReplacements, arrayReplacements, objectReplacements)
-	}
-	return params
-}
-
-// ExtractDefaultParamArrayLengths extract and return the lengths of all array params
-// Example of returned value: {"a-array-params": 2,"b-array-params": 2 }
-func (ps ParamSpecs) ExtractDefaultParamArrayLengths() map[string]int {
-	// Collect all array params
-	arrayParamsLengths := make(map[string]int)
-
-	// Collect array params lengths from defaults
-	for _, p := range ps {
-		if p.Default != nil {
-			if p.Default.Type == ParamTypeArray {
-				arrayParamsLengths[p.Name] = len(p.Default.ArrayVal)
-			}
-		}
-	}
-	return arrayParamsLengths
-}
-
-// extractArrayIndexingParamRefs takes a string of the form `foo-$(params.array-param[1])-bar` and extracts the portions of the string that reference an element in an array param.
-// For example, for the string â€œfoo-$(params.array-param[1])-bar-$(params.other-array-param[2])-$(params.string-param)`,
-// it would return ["$(params.array-param[1])", "$(params.other-array-param[2])"].
-func extractArrayIndexingParamRefs(paramReference string) []string {
-	l := []string{}
-	list := substitution.ExtractArrayIndexingParamsExpressions(paramReference)
-	for _, val := range list {
-		indexString := substitution.ExtractIndexString(val)
-		if indexString != "" {
-			l = append(l, val)
-		}
-	}
-	return l
-}
-
-// extractParamRefsFromSteps get all array indexing references from steps
-func extractParamRefsFromSteps(steps []Step) []string {
-	paramsRefs := []string{}
-	for _, step := range steps {
-		paramsRefs = append(paramsRefs, step.Script)
-		container := step.ToK8sContainer()
-		paramsRefs = append(paramsRefs, extractParamRefsFromContainer(container)...)
-	}
-	return paramsRefs
-}
-
-// extractParamRefsFromStepTemplate get all array indexing references from StepsTemplate
-func extractParamRefsFromStepTemplate(stepTemplate *StepTemplate) []string {
-	if stepTemplate == nil {
-		return nil
-	}
-	container := stepTemplate.ToK8sContainer()
-	return extractParamRefsFromContainer(container)
-}
-
-// extractParamRefsFromSidecars get all array indexing references from sidecars
-func extractParamRefsFromSidecars(sidecars []Sidecar) []string {
-	paramsRefs := []string{}
-	for _, s := range sidecars {
-		paramsRefs = append(paramsRefs, s.Script)
-		container := s.ToK8sContainer()
-		paramsRefs = append(paramsRefs, extractParamRefsFromContainer(container)...)
-	}
-	return paramsRefs
-}
-
-// extractParamRefsFromVolumes get all array indexing references from volumes
-func extractParamRefsFromVolumes(volumes []corev1.Volume) []string {
-	paramsRefs := []string{}
-	for i, v := range volumes {
-		paramsRefs = append(paramsRefs, v.Name)
-		if v.VolumeSource.ConfigMap != nil {
-			paramsRefs = append(paramsRefs, v.ConfigMap.Name)
-			for _, item := range v.ConfigMap.Items {
-				paramsRefs = append(paramsRefs, item.Key)
-				paramsRefs = append(paramsRefs, item.Path)
-			}
-		}
-		if v.VolumeSource.Secret != nil {
-			paramsRefs = append(paramsRefs, v.Secret.SecretName)
-			for _, item := range v.Secret.Items {
-				paramsRefs = append(paramsRefs, item.Key)
-				paramsRefs = append(paramsRefs, item.Path)
-			}
-		}
-		if v.PersistentVolumeClaim != nil {
-			paramsRefs = append(paramsRefs, v.PersistentVolumeClaim.ClaimName)
-		}
-		if v.Projected != nil {
-			for _, s := range volumes[i].Projected.Sources {
-				if s.ConfigMap != nil {
-					paramsRefs = append(paramsRefs, s.ConfigMap.Name)
-				}
-				if s.Secret != nil {
-					paramsRefs = append(paramsRefs, s.Secret.Name)
-				}
-				if s.ServiceAccountToken != nil {
-					paramsRefs = append(paramsRefs, s.ServiceAccountToken.Audience)
-				}
-			}
-		}
-		if v.CSI != nil {
-			if v.CSI.NodePublishSecretRef != nil {
-				paramsRefs = append(paramsRefs, v.CSI.NodePublishSecretRef.Name)
-			}
-			if v.CSI.VolumeAttributes != nil {
-				for _, value := range v.CSI.VolumeAttributes {
-					paramsRefs = append(paramsRefs, value)
-				}
-			}
-		}
-	}
-	return paramsRefs
-}
-
-// extractParamRefsFromContainer get all array indexing references from container
-func extractParamRefsFromContainer(c *corev1.Container) []string {
-	paramsRefs := []string{}
-	paramsRefs = append(paramsRefs, c.Name)
-	paramsRefs = append(paramsRefs, c.Image)
-	paramsRefs = append(paramsRefs, string(c.ImagePullPolicy))
-	paramsRefs = append(paramsRefs, c.Args...)
-
-	for ie, e := range c.Env {
-		paramsRefs = append(paramsRefs, e.Value)
-		if c.Env[ie].ValueFrom != nil {
-			if e.ValueFrom.SecretKeyRef != nil {
-				paramsRefs = append(paramsRefs, e.ValueFrom.SecretKeyRef.LocalObjectReference.Name)
-				paramsRefs = append(paramsRefs, e.ValueFrom.SecretKeyRef.Key)
-			}
-			if e.ValueFrom.ConfigMapKeyRef != nil {
-				paramsRefs = append(paramsRefs, e.ValueFrom.ConfigMapKeyRef.LocalObjectReference.Name)
-				paramsRefs = append(paramsRefs, e.ValueFrom.ConfigMapKeyRef.Key)
-			}
-		}
-	}
-
-	for _, e := range c.EnvFrom {
-		paramsRefs = append(paramsRefs, e.Prefix)
-		if e.ConfigMapRef != nil {
-			paramsRefs = append(paramsRefs, e.ConfigMapRef.LocalObjectReference.Name)
-		}
-		if e.SecretRef != nil {
-			paramsRefs = append(paramsRefs, e.SecretRef.LocalObjectReference.Name)
-		}
-	}
-
-	paramsRefs = append(paramsRefs, c.WorkingDir)
-	paramsRefs = append(paramsRefs, c.Command...)
-
-	for _, v := range c.VolumeMounts {
-		paramsRefs = append(paramsRefs, v.Name)
-		paramsRefs = append(paramsRefs, v.MountPath)
-		paramsRefs = append(paramsRefs, v.SubPath)
-	}
-	return paramsRefs
-}
-
 // ParamType indicates the type of an input parameter;
 // Used to distinguish between a single string and an array of strings.
 type ParamType string
@@ -482,11 +247,11 @@ var AllParamTypes = []ParamType{ParamTypeString, ParamTypeArray, ParamTypeObject
 // Used in JSON unmarshalling so that a single JSON field can accept
 // either an individual string or an array of strings.
 type ParamValue struct {
-	Type      ParamType // Represents the stored type of ParamValues.
-	StringVal string
+	Type      ParamType `json:"type"` // Represents the stored type of ParamValues.
+	StringVal string    `json:"stringVal"`
 	// +listType=atomic
-	ArrayVal  []string
-	ObjectVal map[string]string
+	ArrayVal  []string          `json:"arrayVal"`
+	ObjectVal map[string]string `json:"objectVal"`
 }

 // UnmarshalJSON implements the json.Unmarshaller interface.
@@ -544,64 +309,6 @@ func (paramValues ParamValue) MarshalJSON() ([]byte, error) {
 	}
 }

-// ApplyReplacements applyes replacements for ParamValues type
-func (paramValues *ParamValue) ApplyReplacements(stringReplacements map[string]string, arrayReplacements map[string][]string, objectReplacements map[string]map[string]string) {
-	switch paramValues.Type {
-	case ParamTypeArray:
-		newArrayVal := []string{}
-		for _, v := range paramValues.ArrayVal {
-			newArrayVal = append(newArrayVal, substitution.ApplyArrayReplacements(v, stringReplacements, arrayReplacements)...)
-		}
-		paramValues.ArrayVal = newArrayVal
-	case ParamTypeObject:
-		newObjectVal := map[string]string{}
-		for k, v := range paramValues.ObjectVal {
-			newObjectVal[k] = substitution.ApplyReplacements(v, stringReplacements)
-		}
-		paramValues.ObjectVal = newObjectVal
-	case ParamTypeString:
-		fallthrough
-	default:
-		paramValues.applyOrCorrect(stringReplacements, arrayReplacements, objectReplacements)
-	}
-}
-
-// applyOrCorrect deals with string param whose value can be string literal or a reference to a string/array/object param/result.
-// If the value of paramValues is a reference to array or object, the type will be corrected from string to array/object.
-func (paramValues *ParamValue) applyOrCorrect(stringReplacements map[string]string, arrayReplacements map[string][]string, objectReplacements map[string]map[string]string) {
-	stringVal := paramValues.StringVal
-
-	// if the stringVal is a string literal or a string that mixed with var references
-	// just do the normal string replacement
-	if !exactVariableSubstitutionRegex.MatchString(stringVal) {
-		paramValues.StringVal = substitution.ApplyReplacements(paramValues.StringVal, stringReplacements)
-		return
-	}
-
-	// trim the head "$(" and the tail ")" or "[*])"
-	// i.e. get "params.name" from "$(params.name)" or "$(params.name[*])"
-	trimedStringVal := substitution.StripStarVarSubExpression(stringVal)
-
-	// if the stringVal is a reference to a string param
-	if _, ok := stringReplacements[trimedStringVal]; ok {
-		paramValues.StringVal = substitution.ApplyReplacements(paramValues.StringVal, stringReplacements)
-	}
-
-	// if the stringVal is a reference to an array param, we need to change the type other than apply replacement
-	if _, ok := arrayReplacements[trimedStringVal]; ok {
-		paramValues.StringVal = ""
-		paramValues.ArrayVal = substitution.ApplyArrayReplacements(stringVal, stringReplacements, arrayReplacements)
-		paramValues.Type = ParamTypeArray
-	}
-
-	// if the stringVal is a reference an object param, we need to change the type other than apply replacement
-	if _, ok := objectReplacements[trimedStringVal]; ok {
-		paramValues.StringVal = ""
-		paramValues.ObjectVal = objectReplacements[trimedStringVal]
-		paramValues.Type = ParamTypeObject
-	}
-}
-
 // NewStructuredValues creates an ParamValues of type ParamTypeString or ParamTypeArray, based on
 // how many inputs are given (>1 input will create an array, not string).
 func NewStructuredValues(value string, values ...string) *ParamValue {
@@ -624,72 +331,3 @@ func NewObject(pairs map[string]string) *ParamValue {
 		ObjectVal: pairs,
 	}
 }
-
-// ArrayReference returns the name of the parameter from array parameter reference
-// returns arrayParam from $(params.arrayParam[*])
-func ArrayReference(a string) string {
-	return strings.TrimSuffix(strings.TrimPrefix(a, "$("+ParamsPrefix+"."), "[*])")
-}
-
-// validatePipelineParametersVariablesInTaskParameters validates param value that
-// may contain the reference(s) to other params to make sure those references are used appropriately.
-func validatePipelineParametersVariablesInTaskParameters(params Params, prefix string, paramNames sets.String, arrayParamNames sets.String, objectParamNameKeys map[string][]string) (errs *apis.FieldError) {
-	errs = errs.Also(params.validateDuplicateParameters()).ViaField("params")
-	for _, param := range params {
-		switch param.Value.Type {
-		case ParamTypeArray:
-			for idx, arrayElement := range param.Value.ArrayVal {
-				errs = errs.Also(validateArrayVariable(arrayElement, prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaFieldIndex("value", idx).ViaFieldKey("params", param.Name))
-			}
-		case ParamTypeObject:
-			for key, val := range param.Value.ObjectVal {
-				errs = errs.Also(validateStringVariable(val, prefix, paramNames, arrayParamNames, objectParamNameKeys).ViaFieldKey("properties", key).ViaFieldKey("params", param.Name))
-			}
-		case ParamTypeString:
-			fallthrough
-		default:
-			errs = errs.Also(validateParamStringValue(param, prefix, paramNames, arrayParamNames, objectParamNameKeys))
-		}
-	}
-	return errs
-}
-
-// validateParamStringValue validates the param value field of string type
-// that may contain references to other isolated array/object params other than string param.
-func validateParamStringValue(param Param, prefix string, paramNames sets.String, arrayVars sets.String, objectParamNameKeys map[string][]string) (errs *apis.FieldError) {
-	stringValue := param.Value.StringVal
-
-	// if the provided param value is an isolated reference to the whole array/object, we just check if the param name exists.
-	isIsolated, errs := substitution.ValidateWholeArrayOrObjectRefInStringVariable(param.Name, stringValue, prefix, paramNames)
-	if isIsolated {
-		return errs
-	}
-
-	// if the provided param value is string literal and/or contains multiple variables
-	// valid example: "$(params.myString) and another $(params.myObject.key1)"
-	// invalid example: "$(params.myString) and another $(params.myObject[*])"
-	return validateStringVariable(stringValue, prefix, paramNames, arrayVars, objectParamNameKeys).ViaFieldKey("params", param.Name)
-}
-
-// validateStringVariable validates the normal string fields that can only accept references to string param or individual keys of object param
-func validateStringVariable(value, prefix string, stringVars sets.String, arrayVars sets.String, objectParamNameKeys map[string][]string) *apis.FieldError {
-	errs := substitution.ValidateNoReferencesToUnknownVariables(value, prefix, stringVars)
-	errs = errs.Also(validateObjectVariable(value, prefix, objectParamNameKeys))
-	return errs.Also(substitution.ValidateNoReferencesToProhibitedVariables(value, prefix, arrayVars))
-}
-
-func validateArrayVariable(value, prefix string, stringVars sets.String, arrayVars sets.String, objectParamNameKeys map[string][]string) *apis.FieldError {
-	errs := substitution.ValidateNoReferencesToUnknownVariables(value, prefix, stringVars)
-	errs = errs.Also(validateObjectVariable(value, prefix, objectParamNameKeys))
-	return errs.Also(substitution.ValidateVariableReferenceIsIsolated(value, prefix, arrayVars))
-}
-
-func validateObjectVariable(value, prefix string, objectParamNameKeys map[string][]string) (errs *apis.FieldError) {
-	objectNames := sets.NewString()
-	for objectParamName, keys := range objectParamNameKeys {
-		objectNames.Insert(objectParamName)
-		errs = errs.Also(substitution.ValidateNoReferencesToUnknownVariables(value, fmt.Sprintf("%s\\.%s", prefix, objectParamName), sets.NewString(keys...)))
-	}
-
-	return errs.Also(substitution.ValidateNoReferencesToEntireProhibitedVariables(value, prefix, objectNames))
-}
diff --git a/apis/meta/v1alpha1/param_types_test.go b/apis/meta/v1alpha1/param_types_test.go
index 7191439..874e3c1 100644
--- a/apis/meta/v1alpha1/param_types_test.go
+++ b/apis/meta/v1alpha1/param_types_test.go
@@ -1,5 +1,5 @@
 /*
-Copyright 2022 The Tekton Authors.
+Copyright 2024 The Katanomi Authors.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -14,7 +14,9 @@ See the License for the specific language governing permissions and
 limitations under the License.
 */

-package v1_test
+// Code generated by hack/patch-tekton-params.sh DO NOT EDIT.
+
+package v1alpha1_test

 import (
 	"bytes"
@@ -23,10 +25,10 @@ import (
 	"reflect"
 	"testing"

+	ktesting "github.com/katanomi/pkg/testing"
+
 	"github.com/google/go-cmp/cmp"
-	"github.com/google/go-cmp/cmp/cmpopts"
-	v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
-	"github.com/tektoncd/pipeline/test/diff"
+	"github.com/katanomi/pkg/apis/meta/v1alpha1"
 	"k8s.io/apimachinery/pkg/util/sets"
 	"knative.dev/pkg/apis"
 )
@@ -34,117 +36,117 @@ import (
 func TestParamSpec_SetDefaults(t *testing.T) {
 	tests := []struct {
 		name            string
-		before          *v1.ParamSpec
-		defaultsApplied *v1.ParamSpec
+		before          *v1alpha1.ParamSpec
+		defaultsApplied *v1alpha1.ParamSpec
 	}{{
 		name: "inferred string type",
-		before: &v1.ParamSpec{
+		before: &v1alpha1.ParamSpec{
 			Name: "parametername",
 		},
-		defaultsApplied: &v1.ParamSpec{
+		defaultsApplied: &v1alpha1.ParamSpec{
 			Name: "parametername",
-			Type: v1.ParamTypeString,
+			Type: v1alpha1.ParamTypeString,
 		},
 	}, {
 		name: "inferred type from default value - array",
-		before: &v1.ParamSpec{
+		before: &v1alpha1.ParamSpec{
 			Name: "parametername",
-			Default: &v1.ParamValue{
+			Default: &v1alpha1.ParamValue{
 				ArrayVal: []string{"array"},
 			},
 		},
-		defaultsApplied: &v1.ParamSpec{
+		defaultsApplied: &v1alpha1.ParamSpec{
 			Name: "parametername",
-			Type: v1.ParamTypeArray,
-			Default: &v1.ParamValue{
+			Type: v1alpha1.ParamTypeArray,
+			Default: &v1alpha1.ParamValue{
 				ArrayVal: []string{"array"},
 			},
 		},
 	}, {
 		name: "inferred type from default value - string",
-		before: &v1.ParamSpec{
+		before: &v1alpha1.ParamSpec{
 			Name: "parametername",
-			Default: &v1.ParamValue{
+			Default: &v1alpha1.ParamValue{
 				StringVal: "an",
 			},
 		},
-		defaultsApplied: &v1.ParamSpec{
+		defaultsApplied: &v1alpha1.ParamSpec{
 			Name: "parametername",
-			Type: v1.ParamTypeString,
-			Default: &v1.ParamValue{
+			Type: v1alpha1.ParamTypeString,
+			Default: &v1alpha1.ParamValue{
 				StringVal: "an",
 			},
 		},
 	}, {
 		name: "inferred type from default value - object",
-		before: &v1.ParamSpec{
+		before: &v1alpha1.ParamSpec{
 			Name: "parametername",
-			Default: &v1.ParamValue{
+			Default: &v1alpha1.ParamValue{
 				ObjectVal: map[string]string{"url": "test", "path": "test"},
 			},
 		},
-		defaultsApplied: &v1.ParamSpec{
+		defaultsApplied: &v1alpha1.ParamSpec{
 			Name: "parametername",
-			Type: v1.ParamTypeObject,
-			Default: &v1.ParamValue{
+			Type: v1alpha1.ParamTypeObject,
+			Default: &v1alpha1.ParamValue{
 				ObjectVal: map[string]string{"url": "test", "path": "test"},
 			},
 		},
 	}, {
 		name: "inferred type from properties - PropertySpec type is not provided",
-		before: &v1.ParamSpec{
+		before: &v1alpha1.ParamSpec{
 			Name:       "parametername",
-			Properties: map[string]v1.PropertySpec{"key1": {}},
+			Properties: map[string]v1alpha1.PropertySpec{"key1": {}},
 		},
-		defaultsApplied: &v1.ParamSpec{
+		defaultsApplied: &v1alpha1.ParamSpec{
 			Name:       "parametername",
-			Type:       v1.ParamTypeObject,
-			Properties: map[string]v1.PropertySpec{"key1": {Type: "string"}},
+			Type:       v1alpha1.ParamTypeObject,
+			Properties: map[string]v1alpha1.PropertySpec{"key1": {Type: "string"}},
 		},
 	}, {
 		name: "inferred type from properties - PropertySpec type is provided",
-		before: &v1.ParamSpec{
+		before: &v1alpha1.ParamSpec{
 			Name:       "parametername",
-			Properties: map[string]v1.PropertySpec{"key2": {Type: "string"}},
+			Properties: map[string]v1alpha1.PropertySpec{"key2": {Type: "string"}},
 		},
-		defaultsApplied: &v1.ParamSpec{
+		defaultsApplied: &v1alpha1.ParamSpec{
 			Name:       "parametername",
-			Type:       v1.ParamTypeObject,
-			Properties: map[string]v1.PropertySpec{"key2": {Type: "string"}},
+			Type:       v1alpha1.ParamTypeObject,
+			Properties: map[string]v1alpha1.PropertySpec{"key2": {Type: "string"}},
 		},
 	}, {
 		name: "fully defined ParamSpec - array",
-		before: &v1.ParamSpec{
+		before: &v1alpha1.ParamSpec{
 			Name:        "parametername",
-			Type:        v1.ParamTypeArray,
+			Type:        v1alpha1.ParamTypeArray,
 			Description: "a description",
-			Default: &v1.ParamValue{
+			Default: &v1alpha1.ParamValue{
 				ArrayVal: []string{"array"},
 			},
 		},
-		defaultsApplied: &v1.ParamSpec{
+		defaultsApplied: &v1alpha1.ParamSpec{
 			Name:        "parametername",
-			Type:        v1.ParamTypeArray,
+			Type:        v1alpha1.ParamTypeArray,
 			Description: "a description",
-			Default: &v1.ParamValue{
+			Default: &v1alpha1.ParamValue{
 				ArrayVal: []string{"array"},
 			},
 		},
 	}, {
 		name: "fully defined ParamSpec - object",
-		before: &v1.ParamSpec{
+		before: &v1alpha1.ParamSpec{
 			Name:        "parametername",
-			Type:        v1.ParamTypeObject,
+			Type:        v1alpha1.ParamTypeObject,
 			Description: "a description",
-			Default: &v1.ParamValue{
+			Default: &v1alpha1.ParamValue{
 				ObjectVal: map[string]string{"url": "test", "path": "test"},
 			},
 		},
-		defaultsApplied: &v1.ParamSpec{
+		defaultsApplied: &v1alpha1.ParamSpec{
 			Name:        "parametername",
-			Type:        v1.ParamTypeObject,
+			Type:        v1alpha1.ParamTypeObject,
 			Description: "a description",
-			Default: &v1.ParamValue{
+			Default: &v1alpha1.ParamValue{
 				ObjectVal: map[string]string{"url": "test", "path": "test"},
 			},
 		},
@@ -154,196 +156,52 @@ func TestParamSpec_SetDefaults(t *testing.T) {
 			ctx := context.Background()
 			tc.before.SetDefaults(ctx)
 			if d := cmp.Diff(tc.defaultsApplied, tc.before); d != "" {
-				t.Error(diff.PrintWantGot(d))
-			}
-		})
-	}
-}
-
-func TestParamValues_ApplyReplacements(t *testing.T) {
-	type args struct {
-		input              *v1.ParamValue
-		stringReplacements map[string]string
-		arrayReplacements  map[string][]string
-		objectReplacements map[string]map[string]string
-	}
-	tests := []struct {
-		name           string
-		args           args
-		expectedOutput *v1.ParamValue
-	}{{
-		name: "no replacements on array",
-		args: args{
-			input:              v1.NewStructuredValues("an", "array"),
-			stringReplacements: map[string]string{"some": "value", "anotherkey": "value"},
-			arrayReplacements:  map[string][]string{"arraykey": {"array", "value"}, "sdfdf": {"sdf", "sdfsd"}},
-		},
-		expectedOutput: v1.NewStructuredValues("an", "array"),
-	}, {
-		name: "single string replacement on string",
-		args: args{
-			input:              v1.NewStructuredValues("$(params.myString1)"),
-			stringReplacements: map[string]string{"params.myString1": "value1", "params.myString2": "value2"},
-			arrayReplacements:  map[string][]string{"arraykey": {"array", "value"}, "sdfdf": {"asdf", "sdfsd"}},
-		},
-		expectedOutput: v1.NewStructuredValues("value1"),
-	}, {
-		name: "multiple string replacements on string",
-		args: args{
-			input:              v1.NewStructuredValues("astring$(some) asdf $(anotherkey)"),
-			stringReplacements: map[string]string{"some": "value", "anotherkey": "value"},
-			arrayReplacements:  map[string][]string{"arraykey": {"array", "value"}, "sdfdf": {"asdf", "sdfsd"}},
-		},
-		expectedOutput: v1.NewStructuredValues("astringvalue asdf value"),
-	}, {
-		name: "single array replacement",
-		args: args{
-			input:              v1.NewStructuredValues("firstvalue", "$(arraykey)", "lastvalue"),
-			stringReplacements: map[string]string{"some": "value", "anotherkey": "value"},
-			arrayReplacements:  map[string][]string{"arraykey": {"array", "value"}, "sdfdf": {"asdf", "sdfsd"}},
-		},
-		expectedOutput: v1.NewStructuredValues("firstvalue", "array", "value", "lastvalue"),
-	}, {
-		name: "multiple array replacement",
-		args: args{
-			input:              v1.NewStructuredValues("firstvalue", "$(arraykey)", "lastvalue", "$(sdfdf)"),
-			stringReplacements: map[string]string{"some": "value", "anotherkey": "value"},
-			arrayReplacements:  map[string][]string{"arraykey": {"array", "value"}, "sdfdf": {"asdf", "sdfsd"}},
-		},
-		expectedOutput: v1.NewStructuredValues("firstvalue", "array", "value", "lastvalue", "asdf", "sdfsd"),
-	}, {
-		name: "empty array replacement without extra elements",
-		args: args{
-			input:             v1.NewStructuredValues("$(arraykey)"),
-			arrayReplacements: map[string][]string{"arraykey": {}},
-		},
-		expectedOutput: &v1.ParamValue{Type: v1.ParamTypeArray, ArrayVal: []string{}},
-	}, {
-		name: "empty array replacement with extra elements",
-		args: args{
-			input:              v1.NewStructuredValues("firstvalue", "$(arraykey)", "lastvalue"),
-			stringReplacements: map[string]string{"some": "value", "anotherkey": "value"},
-			arrayReplacements:  map[string][]string{"arraykey": {}},
-		},
-		expectedOutput: v1.NewStructuredValues("firstvalue", "lastvalue"),
-	}, {
-		name: "array replacement on string val",
-		args: args{
-			input:             v1.NewStructuredValues("$(params.myarray)"),
-			arrayReplacements: map[string][]string{"params.myarray": {"a", "b", "c"}},
-		},
-		expectedOutput: v1.NewStructuredValues("a", "b", "c"),
-	}, {
-		name: "array star replacement on string val",
-		args: args{
-			input:             v1.NewStructuredValues("$(params.myarray[*])"),
-			arrayReplacements: map[string][]string{"params.myarray": {"a", "b", "c"}},
-		},
-		expectedOutput: v1.NewStructuredValues("a", "b", "c"),
-	}, {
-		name: "array indexing replacement on string val",
-		args: args{
-			input:              v1.NewStructuredValues("$(params.myarray[0])"),
-			stringReplacements: map[string]string{"params.myarray[0]": "a", "params.myarray[1]": "b"},
-		},
-		expectedOutput: v1.NewStructuredValues("a"),
-	}, {
-		name: "object replacement on string val",
-		args: args{
-			input: v1.NewStructuredValues("$(params.object)"),
-			objectReplacements: map[string]map[string]string{
-				"params.object": {
-					"url":    "abc.com",
-					"commit": "af234",
-				},
-			},
-		},
-		expectedOutput: v1.NewObject(map[string]string{
-			"url":    "abc.com",
-			"commit": "af234",
-		}),
-	}, {
-		name: "object star replacement on string val",
-		args: args{
-			input: v1.NewStructuredValues("$(params.object[*])"),
-			objectReplacements: map[string]map[string]string{
-				"params.object": {
-					"url":    "abc.com",
-					"commit": "af234",
-				},
-			},
-		},
-		expectedOutput: v1.NewObject(map[string]string{
-			"url":    "abc.com",
-			"commit": "af234",
-		}),
-	}, {
-		name: "string replacement on object individual variables",
-		args: args{
-			input: v1.NewObject(map[string]string{
-				"key1": "$(mystring)",
-				"key2": "$(anotherObject.key)",
-			}),
-			stringReplacements: map[string]string{
-				"mystring":          "foo",
-				"anotherObject.key": "bar",
-			},
-		},
-		expectedOutput: v1.NewObject(map[string]string{
-			"key1": "foo",
-			"key2": "bar",
-		}),
-	}}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			tt.args.input.ApplyReplacements(tt.args.stringReplacements, tt.args.arrayReplacements, tt.args.objectReplacements)
-			if d := cmp.Diff(tt.expectedOutput, tt.args.input); d != "" {
-				t.Errorf("ApplyReplacements() output did not match expected value %s", diff.PrintWantGot(d))
+				t.Error(ktesting.PrintDiffWantGot(d))
 			}
 		})
 	}
 }

 type ParamValuesHolder struct {
-	AOrS v1.ParamValue `json:"val"`
+	AOrS v1alpha1.ParamValue `json:"val"`
 }

 func TestParamValues_UnmarshalJSON(t *testing.T) {
 	cases := []struct {
 		input  map[string]interface{}
-		result v1.ParamValue
+		result v1alpha1.ParamValue
 	}{
 		{
 			input:  map[string]interface{}{"val": 123},
-			result: *v1.NewStructuredValues("123"),
+			result: *v1alpha1.NewStructuredValues("123"),
 		},
 		{
 			input:  map[string]interface{}{"val": "123"},
-			result: *v1.NewStructuredValues("123"),
+			result: *v1alpha1.NewStructuredValues("123"),
 		},
 		{
 			input:  map[string]interface{}{"val": ""},
-			result: *v1.NewStructuredValues(""),
+			result: *v1alpha1.NewStructuredValues(""),
 		},
 		{
 			input:  map[string]interface{}{"val": nil},
-			result: v1.ParamValue{Type: v1.ParamTypeString, ArrayVal: nil},
+			result: v1alpha1.ParamValue{Type: v1alpha1.ParamTypeString, ArrayVal: nil},
 		},
 		{
 			input:  map[string]interface{}{"val": []string{}},
-			result: v1.ParamValue{Type: v1.ParamTypeArray, ArrayVal: []string{}},
+			result: v1alpha1.ParamValue{Type: v1alpha1.ParamTypeArray, ArrayVal: []string{}},
 		},
 		{
 			input:  map[string]interface{}{"val": []string{"oneelement"}},
-			result: v1.ParamValue{Type: v1.ParamTypeArray, ArrayVal: []string{"oneelement"}},
+			result: v1alpha1.ParamValue{Type: v1alpha1.ParamTypeArray, ArrayVal: []string{"oneelement"}},
 		},
 		{
 			input:  map[string]interface{}{"val": []string{"multiple", "elements"}},
-			result: v1.ParamValue{Type: v1.ParamTypeArray, ArrayVal: []string{"multiple", "elements"}},
+			result: v1alpha1.ParamValue{Type: v1alpha1.ParamTypeArray, ArrayVal: []string{"multiple", "elements"}},
 		},
 		{
 			input:  map[string]interface{}{"val": map[string]string{"key1": "val1", "key2": "val2"}},
-			result: v1.ParamValue{Type: v1.ParamTypeObject, ObjectVal: map[string]string{"key1": "val1", "key2": "val2"}},
+			result: v1alpha1.ParamValue{Type: v1alpha1.ParamTypeObject, ObjectVal: map[string]string{"key1": "val1", "key2": "val2"}},
 		},
 	}

@@ -376,19 +234,19 @@ func TestParamValues_UnmarshalJSON_Directly(t *testing.T) {
 	cases := []struct {
 		desc     string
 		input    string
-		expected v1.ParamValue
+		expected v1alpha1.ParamValue
 	}{
-		{desc: "empty value", input: ``, expected: *v1.NewStructuredValues("")},
-		{desc: "int value", input: `1`, expected: *v1.NewStructuredValues("1")},
-		{desc: "int array", input: `[1,2,3]`, expected: *v1.NewStructuredValues("[1,2,3]")},
-		{desc: "nested array", input: `[1,\"2\",3]`, expected: *v1.NewStructuredValues(`[1,\"2\",3]`)},
-		{desc: "string value", input: `hello`, expected: *v1.NewStructuredValues("hello")},
-		{desc: "array value", input: `["hello","world"]`, expected: *v1.NewStructuredValues("hello", "world")},
-		{desc: "object value", input: `{"hello":"world"}`, expected: *v1.NewObject(map[string]string{"hello": "world"})},
+		{desc: "empty value", input: ``, expected: *v1alpha1.NewStructuredValues("")},
+		{desc: "int value", input: `1`, expected: *v1alpha1.NewStructuredValues("1")},
+		{desc: "int array", input: `[1,2,3]`, expected: *v1alpha1.NewStructuredValues("[1,2,3]")},
+		{desc: "nested array", input: `[1,\"2\",3]`, expected: *v1alpha1.NewStructuredValues(`[1,\"2\",3]`)},
+		{desc: "string value", input: `hello`, expected: *v1alpha1.NewStructuredValues("hello")},
+		{desc: "array value", input: `["hello","world"]`, expected: *v1alpha1.NewStructuredValues("hello", "world")},
+		{desc: "object value", input: `{"hello":"world"}`, expected: *v1alpha1.NewObject(map[string]string{"hello": "world"})},
 	}

 	for _, c := range cases {
-		v := v1.ParamValue{}
+		v := v1alpha1.ParamValue{}
 		if err := v.UnmarshalJSON([]byte(c.input)); err != nil {
 			t.Errorf("Failed to unmarshal input '%v': %v", c.input, err)
 		}
@@ -417,13 +275,13 @@ func TestParamValues_UnmarshalJSON_Error(t *testing.T) {

 func TestParamValues_MarshalJSON(t *testing.T) {
 	cases := []struct {
-		input  v1.ParamValue
+		input  v1alpha1.ParamValue
 		result string
 	}{
-		{*v1.NewStructuredValues("123"), "{\"val\":\"123\"}"},
-		{*v1.NewStructuredValues("123", "1234"), "{\"val\":[\"123\",\"1234\"]}"},
-		{*v1.NewStructuredValues("a", "a", "a"), "{\"val\":[\"a\",\"a\",\"a\"]}"},
-		{*v1.NewObject(map[string]string{"key1": "var1", "key2": "var2"}), "{\"val\":{\"key1\":\"var1\",\"key2\":\"var2\"}}"},
+		{*v1alpha1.NewStructuredValues("123"), "{\"val\":\"123\"}"},
+		{*v1alpha1.NewStructuredValues("123", "1234"), "{\"val\":[\"123\",\"1234\"]}"},
+		{*v1alpha1.NewStructuredValues("a", "a", "a"), "{\"val\":[\"a\",\"a\",\"a\"]}"},
+		{*v1alpha1.NewObject(map[string]string{"key1": "var1", "key2": "var2"}), "{\"val\":{\"key1\":\"var1\",\"key2\":\"var2\"}}"},
 	}

 	for _, c := range cases {
@@ -438,267 +296,61 @@ func TestParamValues_MarshalJSON(t *testing.T) {
 	}
 }

-func TestArrayReference(t *testing.T) {
-	tests := []struct {
-		name, p, expectedResult string
-	}{{
-		name:           "valid array parameter expression with star notation returns param name",
-		p:              "$(params.arrayParam[*])",
-		expectedResult: "arrayParam",
-	}, {
-		name:           "invalid array parameter without dollar notation returns the input as is",
-		p:              "params.arrayParam[*]",
-		expectedResult: "params.arrayParam[*]",
-	}}
-	for _, tt := range tests {
-		if d := cmp.Diff(tt.expectedResult, v1.ArrayReference(tt.p)); d != "" {
-			t.Error(diff.PrintWantGot(d))
-		}
-	}
-}
-
 func TestExtractNames(t *testing.T) {
 	tests := []struct {
 		name   string
-		params v1.Params
-		want   sets.String
+		params v1alpha1.Params
+		want   sets.Set[string]
 	}{{
 		name:   "no params",
-		params: v1.Params{{}},
-		want:   sets.NewString(""),
+		params: v1alpha1.Params{{}},
+		want:   sets.New(""),
 	}, {
 		name: "extract param names from ParamTypeString",
-		params: v1.Params{{
-			Name: "IMAGE", Value: v1.ParamValue{Type: v1.ParamTypeString, StringVal: "image-1"},
+		params: v1alpha1.Params{{
+			Name: "IMAGE", Value: v1alpha1.ParamValue{Type: v1alpha1.ParamTypeString, StringVal: "image-1"},
 		}, {
-			Name: "DOCKERFILE", Value: v1.ParamValue{Type: v1.ParamTypeString, StringVal: "path/to/Dockerfile1"},
+			Name: "DOCKERFILE", Value: v1alpha1.ParamValue{Type: v1alpha1.ParamTypeString, StringVal: "path/to/Dockerfile1"},
 		}},
-		want: sets.NewString("IMAGE", "DOCKERFILE"),
+		want: sets.New("IMAGE", "DOCKERFILE"),
 	}, {
 		name: "extract param names from ParamTypeArray",
-		params: v1.Params{{
-			Name: "GOARCH", Value: v1.ParamValue{Type: v1.ParamTypeArray, ArrayVal: []string{"linux/amd64", "linux/ppc64le", "linux/s390x"}},
+		params: v1alpha1.Params{{
+			Name: "GOARCH", Value: v1alpha1.ParamValue{Type: v1alpha1.ParamTypeArray, ArrayVal: []string{"linux/amd64", "linux/ppc64le", "linux/s390x"}},
 		}},
-		want: sets.NewString("GOARCH"),
+		want: sets.New("GOARCH"),
 	}, {
 		name: "extract param names from ParamTypeString and ParamTypeArray",
-		params: v1.Params{{
-			Name: "GOARCH", Value: v1.ParamValue{Type: v1.ParamTypeArray, ArrayVal: []string{"linux/amd64", "linux/ppc64le", "linux/s390x"}},
+		params: v1alpha1.Params{{
+			Name: "GOARCH", Value: v1alpha1.ParamValue{Type: v1alpha1.ParamTypeArray, ArrayVal: []string{"linux/amd64", "linux/ppc64le", "linux/s390x"}},
 		}, {
-			Name: "IMAGE", Value: v1.ParamValue{Type: v1.ParamTypeString, StringVal: "image-1"},
+			Name: "IMAGE", Value: v1alpha1.ParamValue{Type: v1alpha1.ParamTypeString, StringVal: "image-1"},
 		}},
-		want: sets.NewString("GOARCH", "IMAGE"),
+		want: sets.New("GOARCH", "IMAGE"),
 	}, {
 		name: "extract param name from duplicate params",
-		params: v1.Params{{
-			Name: "duplicate", Value: v1.ParamValue{Type: v1.ParamTypeArray, ArrayVal: []string{"linux/amd64", "linux/ppc64le", "linux/s390x"}},
+		params: v1alpha1.Params{{
+			Name: "duplicate", Value: v1alpha1.ParamValue{Type: v1alpha1.ParamTypeArray, ArrayVal: []string{"linux/amd64", "linux/ppc64le", "linux/s390x"}},
 		}, {
-			Name: "duplicate", Value: v1.ParamValue{Type: v1.ParamTypeString, StringVal: "image-1"},
+			Name: "duplicate", Value: v1alpha1.ParamValue{Type: v1alpha1.ParamTypeString, StringVal: "image-1"},
 		}},
-		want: sets.NewString("duplicate"),
+		want: sets.New("duplicate"),
 	}}
 	for _, tt := range tests {
-		if d := cmp.Diff(tt.want, v1.Params.ExtractNames(tt.params)); d != "" {
-			t.Error(diff.PrintWantGot(d))
+		if d := cmp.Diff(tt.want, v1alpha1.Params.ExtractNames(tt.params)); d != "" {
+			t.Error(ktesting.PrintDiffWantGot(d))
 		}
 	}
 }

-func TestParams_ReplaceVariables(t *testing.T) {
-	tests := []struct {
-		name               string
-		ps                 v1.Params
-		stringReplacements map[string]string
-		arrayReplacements  map[string][]string
-		objectReplacements map[string]map[string]string
-		want               v1.Params
-	}{
-		{
-			name: "string replacement",
-			ps: v1.Params{{
-				Name:  "foo",
-				Value: v1.ParamValue{StringVal: "$(params.foo)"},
-			}},
-			stringReplacements: map[string]string{
-				"params.foo": "bar",
-			},
-			want: v1.Params{{
-				Name:  "foo",
-				Value: v1.ParamValue{StringVal: "bar"},
-			}},
-		},
-		{
-			name: "array replacement",
-			ps: v1.Params{{
-				Name:  "foo",
-				Value: v1.ParamValue{StringVal: "$(params.foo)"},
-			}},
-			arrayReplacements: map[string][]string{
-				"params.foo": {"bar", "zoo"},
-			},
-			want: v1.Params{{
-				Name:  "foo",
-				Value: v1.ParamValue{Type: v1.ParamTypeArray, ArrayVal: []string{"bar", "zoo"}},
-			}},
-		},
-		{
-			name: "object replacement",
-			ps: v1.Params{{
-				Name:  "foo",
-				Value: v1.ParamValue{StringVal: "$(params.foo)"},
-			}},
-			objectReplacements: map[string]map[string]string{
-				"params.foo": {
-					"abc": "123",
-				},
-			},
-			want: v1.Params{{
-				Name:  "foo",
-				Value: v1.ParamValue{Type: v1.ParamTypeObject, ObjectVal: map[string]string{"abc": "123"}},
-			}},
-		},
-	}
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			got := tt.ps.ReplaceVariables(tt.stringReplacements, tt.arrayReplacements, tt.objectReplacements)
-			if d := cmp.Diff(tt.want, got); d != "" {
-				t.Error(diff.PrintWantGot(d))
-			}
-		})
-	}
-}
-
-func TestExtractParamArrayLengths(t *testing.T) {
-	tcs := []struct {
-		name   string
-		params v1.Params
-		want   map[string]int
-	}{{
-		name:   "string params",
-		params: v1.Params{{Name: "foo", Value: v1.ParamValue{StringVal: "bar", Type: v1.ParamTypeString}}},
-		want:   nil,
-	}, {
-		name:   "one array param",
-		params: v1.Params{{Name: "foo", Value: v1.ParamValue{ArrayVal: []string{"bar", "baz"}, Type: v1.ParamTypeArray}}},
-		want:   map[string]int{"foo": 2},
-	}, {
-		name:   "object params",
-		params: v1.Params{{Name: "foo", Value: v1.ParamValue{ObjectVal: map[string]string{"bar": "baz"}, Type: v1.ParamTypeObject}}},
-		want:   nil,
-	}, {
-		name: "multiple array params",
-		params: v1.Params{
-			{Name: "foo", Value: v1.ParamValue{ArrayVal: []string{"bar", "baz"}, Type: v1.ParamTypeArray}},
-			{Name: "abc", Value: v1.ParamValue{ArrayVal: []string{"123", "456", "789"}, Type: v1.ParamTypeArray}},
-			{Name: "empty", Value: v1.ParamValue{ArrayVal: []string{}, Type: v1.ParamTypeArray}},
-		},
-		want: map[string]int{"foo": 2, "abc": 3, "empty": 0},
-	}, {
-		name: "mixed param types",
-		params: v1.Params{
-			{Name: "foo", Value: v1.ParamValue{StringVal: "abc", Type: v1.ParamTypeString}},
-			{Name: "bar", Value: v1.ParamValue{ArrayVal: []string{"def", "ghi"}, Type: v1.ParamTypeArray}},
-			{Name: "baz", Value: v1.ParamValue{ObjectVal: map[string]string{"jkl": "mno"}, Type: v1.ParamTypeObject}},
-		},
-		want: map[string]int{"bar": 2},
-	}}
-	for _, tc := range tcs {
-		t.Run(tc.name, func(t *testing.T) {
-			got := tc.params.ExtractParamArrayLengths()
-			if d := cmp.Diff(tc.want, got, cmpopts.EquateEmpty()); d != "" {
-				t.Errorf("wrong param array lengths: %s", d)
-			}
-		})
-	}
-}
-
-func TestExtractDefaultParamArrayLengths(t *testing.T) {
-	tcs := []struct {
-		name   string
-		params v1.ParamSpecs
-		want   map[string]int
-	}{{
-		name:   "string params",
-		params: v1.ParamSpecs{{Name: "foo", Default: &v1.ParamValue{StringVal: "bar", Type: v1.ParamTypeString}}},
-		want:   nil,
-	}, {
-		name:   "one array param",
-		params: v1.ParamSpecs{{Name: "foo", Default: &v1.ParamValue{ArrayVal: []string{"bar", "baz"}, Type: v1.ParamTypeArray}}},
-		want:   map[string]int{"foo": 2},
-	}, {
-		name:   "object params",
-		params: v1.ParamSpecs{{Name: "foo", Default: &v1.ParamValue{ObjectVal: map[string]string{"bar": "baz"}, Type: v1.ParamTypeObject}}},
-		want:   nil,
-	}, {
-		name: "multiple array params",
-		params: v1.ParamSpecs{
-			{Name: "foo", Default: &v1.ParamValue{ArrayVal: []string{"bar", "baz"}, Type: v1.ParamTypeArray}},
-			{Name: "abc", Default: &v1.ParamValue{ArrayVal: []string{"123", "456", "789"}, Type: v1.ParamTypeArray}},
-			{Name: "empty", Default: &v1.ParamValue{ArrayVal: []string{}, Type: v1.ParamTypeArray}},
-		},
-		want: map[string]int{"foo": 2, "abc": 3, "empty": 0},
-	}, {
-		name: "mixed param types",
-		params: v1.ParamSpecs{
-			{Name: "foo", Default: &v1.ParamValue{StringVal: "abc", Type: v1.ParamTypeString}},
-			{Name: "bar", Default: &v1.ParamValue{ArrayVal: []string{"def", "ghi"}, Type: v1.ParamTypeArray}},
-			{Name: "baz", Default: &v1.ParamValue{ObjectVal: map[string]string{"jkl": "mno"}, Type: v1.ParamTypeObject}},
-		},
-		want: map[string]int{"bar": 2},
-	}}
-	for _, tc := range tcs {
-		t.Run(tc.name, func(t *testing.T) {
-			got := tc.params.ExtractDefaultParamArrayLengths()
-			if d := cmp.Diff(tc.want, got, cmpopts.EquateEmpty()); d != "" {
-				t.Errorf("wrong default param array lengths: %s", d)
-			}
-		})
-	}
-}
-
-func TestParseTaskandResultName(t *testing.T) {
-	tcs := []struct {
-		name             string
-		param            v1.Param
-		pipelineTaskName string
-		resultName       string
-	}{{
-		name:             "matrix length context var",
-		param:            v1.Param{Name: "foo", Value: v1.ParamValue{StringVal: "$(tasks.matrix-emitting-results.matrix.length)", Type: v1.ParamTypeString}},
-		pipelineTaskName: "matrix-emitting-results",
-	}, {
-		name:             "matrix results length context var",
-		param:            v1.Param{Name: "foo", Value: v1.ParamValue{StringVal: "$(tasks.myTask.matrix.ResultName.length)", Type: v1.ParamTypeString}},
-		pipelineTaskName: "myTask",
-		resultName:       "ResultName",
-	}, {
-		name:             "empty context var",
-		param:            v1.Param{Name: "foo", Value: v1.ParamValue{StringVal: "", Type: v1.ParamTypeString}},
-		pipelineTaskName: "",
-		resultName:       "",
-	}}
-	for _, tc := range tcs {
-		t.Run(tc.name, func(t *testing.T) {
-			pipelineTaskName, resultName := tc.param.ParseTaskandResultName()
-
-			if d := cmp.Diff(tc.pipelineTaskName, pipelineTaskName); d != "" {
-				t.Error(diff.PrintWantGot(d))
-			}
-			if d := cmp.Diff(tc.resultName, resultName); d != "" {
-				t.Error(diff.PrintWantGot(d))
-			}
-		})
-	}
-}
-
 func TestGetNames(t *testing.T) {
 	tcs := []struct {
 		name   string
-		params v1.ParamSpecs
+		params v1alpha1.ParamSpecs
 		want   []string
 	}{{
 		name: "names from param spec",
-		params: v1.ParamSpecs{{
+		params: v1alpha1.ParamSpecs{{
 			Name: "foo",
 		}, {
 			Name: "bar",
@@ -709,7 +361,7 @@ func TestGetNames(t *testing.T) {
 		t.Run(tc.name, func(t *testing.T) {
 			got := tc.params.GetNames()
 			if d := cmp.Diff(tc.want, got); d != "" {
-				t.Error(diff.PrintWantGot(d))
+				t.Error(ktesting.PrintDiffWantGot(d))
 			}
 		})
 	}
@@ -718,11 +370,11 @@ func TestGetNames(t *testing.T) {
 func TestSortByType(t *testing.T) {
 	tcs := []struct {
 		name   string
-		params v1.ParamSpecs
-		want   []v1.ParamSpecs
+		params v1alpha1.ParamSpecs
+		want   []v1alpha1.ParamSpecs
 	}{{
 		name: "sort by type",
-		params: v1.ParamSpecs{{
+		params: v1alpha1.ParamSpecs{{
 			Name: "array1",
 			Type: "array",
 		}, {
@@ -741,7 +393,7 @@ func TestSortByType(t *testing.T) {
 			Name: "object2",
 			Type: "object",
 		}},
-		want: []v1.ParamSpecs{
+		want: []v1alpha1.ParamSpecs{
 			{{
 				Name: "string1",
 				Type: "string",
@@ -768,9 +420,9 @@ func TestSortByType(t *testing.T) {
 	for _, tc := range tcs {
 		t.Run(tc.name, func(t *testing.T) {
 			s, a, o := tc.params.SortByType()
-			got := []v1.ParamSpecs{s, a, o}
+			got := []v1alpha1.ParamSpecs{s, a, o}
 			if d := cmp.Diff(tc.want, got); d != "" {
-				t.Error(diff.PrintWantGot(d))
+				t.Error(ktesting.PrintDiffWantGot(d))
 			}
 		})
 	}
@@ -779,18 +431,18 @@ func TestSortByType(t *testing.T) {
 func TestValidateNoDuplicateNames(t *testing.T) {
 	tcs := []struct {
 		name          string
-		params        v1.ParamSpecs
+		params        v1alpha1.ParamSpecs
 		expectedError *apis.FieldError
 	}{{
 		name: "no duplicates",
-		params: v1.ParamSpecs{{
+		params: v1alpha1.ParamSpecs{{
 			Name: "foo",
 		}, {
 			Name: "bar",
 		}},
 	}, {
 		name: "duplicates",
-		params: v1.ParamSpecs{{
+		params: v1alpha1.ParamSpecs{{
 			Name: "foo",
 		}, {
 			Name: "foo",
@@ -804,7 +456,7 @@ func TestValidateNoDuplicateNames(t *testing.T) {
 		t.Run(tc.name, func(t *testing.T) {
 			got := tc.params.ValidateNoDuplicateNames()
 			if d := cmp.Diff(tc.expectedError.Error(), got.Error()); d != "" {
-				t.Error(diff.PrintWantGot(d))
+				t.Error(ktesting.PrintDiffWantGot(d))
 			}
 		})
 	}
--
2.39.3 (Apple Git-145)

